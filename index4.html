<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>D3 Tree with Pie Chart Nodes (Cartesian)</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
        }

        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 1.5px;
        }

        .node text {
            font-size: 10px;
            text-anchor: middle;
            dominant-baseline: middle;
        }
    </style>
</head>

<body>
    <svg width="1200" height="1000"></svg>
    <script>

        const width = 1500;
        const height = 1000;

        const svg = d3.select("svg")
            .attr("viewBox", [0, 0, width, height])
            .call(d3.zoom()
                .scaleExtent([0.3, 15])
                .on("zoom", (event) => {
                    g.attr("transform", event.transform);
                }));

        const g = svg.append("g").attr("transform", "translate(80,80)");

        function getColors(categories) {
            const colorScale = d3.scaleOrdinal(d3.schemeCategory10);
            const colorMap = {};
            categories.forEach(cat => colorMap[cat] = colorScale(cat));
            return colorMap;
        }

        function getPieChartData(items, colorMap) {
            const countMap = {};
            for (const item of items) countMap[item] = (countMap[item] || 0) + 1;
            const total = items.length;
            return Object.entries(countMap).map(([label, count]) => ({
                label,
                value: count / total,
                count,
                color: colorMap[label] || '#cccccc'
            }));
        }

        function countAllDescendants(node) {
            if (!node.children || node.children.length === 0) {
                node.data.nchild = 0;
                return 0;
            }
            const count = node.children.reduce((sum, child) => sum + 1 + countAllDescendants(child), 0);
            node.data.nchild = count;
            return count;
        }

        function createRadiusScaler(root) {
            const counts = root.descendants().map(d => d.data.nchild);
            const min = Math.sqrt(Math.min(...counts) + 1);
            const max = Math.sqrt(Math.max(...counts) + 1);
            return (n) => {
                const scaled = Math.sqrt(n + 1);
                return ((scaled - min) / (max - min)) * (10 - 3) + 3;
            };
        }

        function collectPieValues(node, metaname, categorySet) {
            if (!node.children || node.children.length === 0) {
                const value = node.data.meta[metaname];
                node.data.pieValues = [value];
                categorySet.add(value);
                return [value];
            }
            const values = node.children.flatMap(child => collectPieValues(child, metaname, categorySet));
            node.data.pieValues = values;
            return values;
        }

        function assignLeafColors(node, metaname, colorMap) {
            if (!node.children || node.children.length === 0) {
                node.data.color = colorMap[node.data.meta[metaname]];
            } else {
                node.children.forEach(child => assignLeafColors(child, metaname, colorMap));
            }
        }

        function renderLinks(group, root) {
            group.selectAll(".link")
                .data(root.links())
                .enter()
                .append("path")
                .attr("class", "link")
                .attr("d", d => `M${d.source.x},${d.source.y}V${d.target.y}H${d.target.x}`);
        }

        function renderNodes(group, root, colors) {
            const nodes = group.selectAll(".node")
                .data(root.descendants())
                .enter().append("g")
                .attr("class", "node")
                .attr("transform", d => `translate(${d.x},${d.y})`);

            nodes.each(function (d) {
                const r = d.data.radius || 3;
                const nodeGroup = d3.select(this);

                if (!d.children || d.children.length === 0) {
                    const side = r * 2;
                    const height = Math.sqrt(3) / 2 * side;
                    const points = [
                        [0, -height / 2],
                        [-side / 2, height / 2],
                        [side / 2, height / 2]
                    ];
                    const pathData = d3.line()(points.concat([points[0]]));
                    nodeGroup.append("path")
                        .attr("d", pathData)
                        .attr("fill", d.data.color)
                        .attr("stroke", "black")
                        .attr("stroke-width", 0.0);
                } else {
                    const pieData = getPieChartData(d.data.pieValues, colors);
                    const pie = d3.pie().value(d => d.value)(pieData);
                    const arc = d3.arc().innerRadius(0).outerRadius(r);
                    nodeGroup.selectAll("path")
                        .data(pie)
                        .enter()
                        .append("path")
                        .attr("d", arc)
                        .attr("fill", d => d.data.color);
                }
            });
        }

        d3.json("tree_output.json").then(data => {
            const root = d3.hierarchy(data);
            countAllDescendants(root);

            const radiusScaler = createRadiusScaler(root);
            root.descendants().forEach(d => d.data.radius = radiusScaler(d.data.nchild));

            const treeLayout = d3.tree()
                .size([width*0.9, height])
                .separation((a, b) => {
                    const r1 = a.data.radius * 2 || 3;
                    const r2 = b.data.radius * 2 || 3;
                    return (r1 + r2 + 10) / 6;
                });
            treeLayout(root);

            const pieCategories = new Set();
            collectPieValues(root, "host", pieCategories);
            const colorMap = getColors(Array.from(pieCategories));
            assignLeafColors(root, "host", colorMap);

            renderLinks(g, root);
            renderNodes(g, root, colorMap);
        });
    </script>


</body>

</html>