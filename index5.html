<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Read2TreeView</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

    <style>
        body {
            font-family: sans-serif;
        }

        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 1.5px;
        }

        .node text {
            font-size: 10px;
            text-anchor: middle;
            dominant-baseline: middle;
        }

        .section-title {
            font-size: 14px;
            font-weight: bold;
            margin-top: 16px;
            margin-bottom: 8px;
        }

        ul {
            padding-left: 20px;
        }

        code {
            background-color: #f4f4f4;
            padding: 1px 4px;
            border-radius: 3px;
            font-family: monospace;
        }

        .orange-theme {
            --primary-color: #f7990c;
            --primary-color-dark: #FB8C00;
            --text-on-primary: white;
        }


        .orange-theme button {
            background-color: var(--primary-color);
            color: var(--text-on-primary);
            border: none;
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }

        .orange-theme button:hover {
            background-color: var(--primary-color-dark);
        }

        .orange-theme button:active {
            transform: scale(0.97);
        }

        .orange-theme .header,
        .orange-theme #footer {
            background-color: var(--primary-color);
            color: var(--text-on-primary);
        }

        button {
            background-color: #FFA726;
            color: white;
            border: none;
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }

        button:hover {
            background-color: #FB8C00;
        }

        button:active {
            transform: scale(0.97);
        }

        .help-tooltip-wrapper {
            position: relative;
            display: inline-block;
            cursor: pointer;
        }

        .help-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: transparent;
            /* color: white; */
            text-align: center;
            line-height: 20px;
            font-weight: bold;
            font-size: 14px;
            user-select: none;
        }

        .tooltip-content {
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.2s;
            position: absolute;
            top: 120%;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: #fff;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 100;
            white-space: normal;
            width: 200px;
            word-wrap: break-word;
        }

        .help-tooltip-wrapper:hover .tooltip-content {
            visibility: visible;
            opacity: 1;
        }


        .hide-scrollbar::-webkit-scrollbar {
            display: none;
        }
    </style>
</head>

<body style="margin: 0; height: 100vh;font-size: 14px;">
    <div id="app" class="orange-theme" style="display: flex; flex-direction: column; height: 100vh;">

        <!-- Header -->
        <div id="header" class="header"
            style=" color:#f7f5f3;  padding: 0 20px; display: flex; justify-content: space-between; align-items: center; height: 5vh;  position: relative;">

            <h4 style="margin: 0;">Read2TreeView</h4>

            <div style="display: flex; align-items: center; gap: 10px;">
                <label for="currMeta">Main Palette <helper>The main palette is used to color all nodes. Non-leaf
                        nodes (pie charts) are fully colored using the main palette. For leaf nodes (squares), the
                        top-left corner is colored with the main palette, while the rest is filled using the extra
                        palette. Select the corresponding metadata from the dropdown menu; the palette will appear to
                        the right of the selection box. Sample node colors can be configured using the boxes on the
                        right.

                    </helper>
                    <select id="currMeta" name="currMeta" v-model="selectedMeta">
                        <option v-for="meta in meta_names" :value="meta">{{ meta }}</option>
                    </select>
                    <palette :color-map="main_color_map"></palette>
                </label>
                |
                <label for="currMeta">Right Top Palette <helper>
                        The extra palette is used to render square leaf nodes (representing sample nodes). The top-left
                        corner shows the main palette color, This palette is used to color the right-top corner of the
                        square leaf nodes.
                    </helper>

                    <select id="extraMeta1" name="extraMeta1" v-model="extraMeta1">
                        <option v-for="meta in extraMeta1Names" :value="meta">{{ meta }}</option>
                    </select>
                    <palette :color-map="extraMeta1ColorMap"></palette>

                </label>|
                <label>Bottom Left Palette <helper>
                        The extra palette is used to render square leaf nodes (representing sample nodes). The
                        bottom-left
                        corner shows the main palette color, This palette is used to color the bottom-left corner of the
                        square leaf nodes.
                    </helper>

                    <select id="extraMeta2" name="extraMeta2" v-model="extraMeta2">
                        <option v-for="meta in extraMeta2Names" :value="meta">{{ meta }}</option>
                    </select>
                    <palette :color-map="extraMeta2ColorMap"></palette>

                </label>|
                <label>
                    Bottom Right Palette <helper>
                        The extra palette is used to render square leaf nodes (representing sample nodes). The
                        bottom-right
                        corner shows the main palette color, This palette is used to color the bottom-right corner of
                        the
                        square leaf nodes.
                    </helper>
                    <select id="extraMeta3" name="extraMeta3" v-model="extraMeta3">
                        <option v-for="meta in extraMeta3Names" :value="meta">{{ meta }}</option>
                    </select>
                    <palette :color-map="extraMeta3ColorMap"></palette>
                </label>

<!-- <button @click="exportSVG">Export SVG</button> -->

            </div>
        </div>

        <!-- Main content area -->
        <div id="main" style="display: flex; height: 90vh;">

            <div id="left_panel"
                style="width: 15%; background-color: #FAFAFA; padding: 3px;  overflow: auto;border: 1px solid black;border-right: none;">

                <div style="height: 50%; border-bottom: 1px solid black; overflow-y: scroll; scrollbar-width: none; -ms-overflow-style: none;"
                    class="hide-scrollbar">

                    <div style="display: flex; justify-content: space-between; margin-top:4px;margin-bottom: 4px;">
                        <div style="
                                width: 100%;
                                background-color: #FFA726;
                                color: white;
                                padding: 6px 0;
                                font-size: 14px;
                                font-weight: bold;
                                border-radius: 4px;
                                text-align: center;
                                user-select: none;
                                box-shadow: 1px 1px 3px rgba(0,0,0,0.1);
                                ">
                            Tree Information
                        </div>

                    </div>

                    <collapse-panel>
                        <template #title>
                            <strong>Basic:
                                <helper :color="'#000'">Basic information about the tree.</helper>
                            </strong>
                        </template>
                        <template #content>
                            <div style="padding: 4px; font-size: 12px;">
                                <div> <strong>Tree Name:</strong> {{ meta_keys && meta_keys.name || "" }}</div>
                                <div> <strong>#Node:</strong> {{ node_list && node_list.length }},
                                    <strong>#Sample:</strong> {{ num_leaf_nodes }}
                                </div>
                                <div> <strong>Metadata:</strong>
                                    <helper :color="'#CCCCCC'">Metadata is used to color the nodes. The metadata
                                        names and their types are listed below.</helper>
                                </div>
                                <div style="margin-top: 4px;">
                                    <div v-for="item in meta_keys.meta_keys" :key="item.name"
                                        style="display: flex; justify-content: space-between; background-color: #333; color: white; padding: 4px; margin-bottom: 2px; border-radius: 4px;">
                                        <span>{{ item.name }}</span>
                                        <span>
                                            {{
                                            item.std_type === 'cate' ? 'category variable'
                                            : item.std_type === 'cont' ? 'continue variable'
                                            : item.std_type
                                            }}
                                        </span>
                                    </div>
                                </div>
                            </div>
                        </template>
                    </collapse-panel>



                    <collapse-panel>
                        <template #title>
                            <strong>Adjsut Tree:
                                <helper :color="'#000'">Adjust the tree size. The tree will be redrawn
                                    after the adjustment.
                                    Note that this operation will cause performance issues if the tree is
                                    too large.</helper>
                                </helper>
                            </strong>
                        </template>
                        <template #content>
                            <div style="padding: 4px; font-size: 12px;">

                                <div
                                    style="margin: 12px 0; padding: 6px 12px; border: 1px solid #ccc; border-radius: 6px; background-color: #f9f9f9;">
                                    <div style="text-align: center; font-size: 14px; margin-bottom: 10px;">
                                        <strong>Current canvas size:</strong> {{ svgwidth }} × {{ svgheight }}
                                    </div>

                                    <div style="display: flex; flex-direction: column; align-items: center; gap: 10px;">
                                        <div style="display: flex; gap: 10px;">
                                            <button @click="changeCanvasReDrawTree('width', 500)">Increase
                                                Width</button>
                                            <button @click="changeCanvasReDrawTree('width', -500)">Decrease
                                                Width</button>
                                        </div>
                                        <div style="display: flex; gap: 10px;">
                                            <button @click="changeCanvasReDrawTree('height', 500)">Increase
                                                Height</button>
                                            <button @click="changeCanvasReDrawTree('height', -500)">Decrease
                                                Height</button>
                                        </div>
                                    </div>
                                </div>


                            </div>

                        </template>
                    </collapse-panel>



                </div>

                <div style="height: 49%; border-bottom: 1px solid black; overflow-y: scroll; scrollbar-width: none; -ms-overflow-style: none;"
                    class="hide-scrollbar">
                    <div style="display: flex; justify-content: space-between; margin-top:4px;margin-bottom: 4px;">
                        <div style="
                                width: 100%;
                                background-color: #FFA726;
                                color: white;
                                padding: 6px 0;
                                font-size: 14px;
                                font-weight: bold;
                                border-radius: 4px;
                                text-align: center;
                                user-select: none;
                                box-shadow: 1px 1px 3px rgba(0,0,0,0.1);
                                ">
                            Tree Filters
                        </div>

                    </div>

                    <div style="margin-top: 4px;margin-bottom: 4px; display:flex;align-items: right; gap: 10px;">

                        <!-- <button @click="clear_all_filters">Remove Filters</button> -->
                        <button @click="apply_filter">Apply Filters</button>

                    </div>

                    <!-- <collapse-panel>
                        <template #title>
                            <strong>Confidence Filter:
                            </strong>
                        </template>
                        <template #content>

                            <label>
                                <input type="checkbox" name="agree" value="yes">
                                Apply
                            </label>

                            <div>
                                <label for="min">Min:</label>
                                <input type="number" id="min" v-model="confidence_filter.min" min="0" max="100"
                                    step="1">
                                <label for="max">Max:</label>
                                <input type="number" id="max" v-model="confidence_filter.max" min="0" max="100"
                                    step="1">
                            </div>


                        </template>
                    </collapse-panel> -->
                    <collapse-panel>
                        <template #title>
                            <strong>Tree Internal Confidence Filter:</strong>
                        </template>
                        <template #content>
                            <range-filter :name="''" :min-value="0" :max-value="100"
                                @update:apply="is_confidence_applied = $event"
                                @update:range="val => { confidence_filter.min = val.min; confidence_filter.max = val.max }" />

                        </template>
                    </collapse-panel>

                    <collapse-panel>
                        <template #title>
                            <strong>Sample Metadata Filters:
                            </strong>
                        </template>
                        <template #content>

                            <!-- range values in metadata -->
                            <!-- <div v-for="item in meta_keys.meta_keys" :key="item.name">
                                <div v-if="item.std_type === 'cont'">



                                </div>
                            </div> -->

                            <div v-if="meta_keys && meta_keys.meta_keys">
                                <div v-for="item in Object.values(meta_keys.meta_keys).filter(m => m.std_type === 'cont')"
                                    :key="item.name">
                                    <range-filter :name="item.name" :min-value="item.min" :max-value="item.max"
                                        @update:apply="metadata_filters[item.name].applied= $event"
                                        @update:range="val => { metadata_filters[item.name].min = val.min; metadata_filters[item.name].max = val.max }" />
                                </div>
                            </div>



                            <div v-if="meta_keys && meta_keys.meta_keys">
                                <div v-for="item in Object.values(meta_keys.meta_keys).filter(m => m.std_type === 'cate')"
                                    :key="item.name">
                                    <category-filter :name="item.name" :candidates="item.categories"
                                        @update:apply="metadata_filters[item.name].applied= $event"
                                        @update:selected="metadata_filters[item.name].selected = $event" />
                                </div>
                            </div>



                            <!-- <div>
                                <label>
                                    <input type="checkbox" name="agree" value="yes">
                                    Apply
                                </label>
                                <form>
                                    <div
                                        v-for="item in (meta_keys && meta_keys.meta_keys && meta_keys.meta_keys['subgroup'].categories || [])">
                                        <label><input type="checkbox" name="fruits" value="item">{{item}}</label><br>
                                    </div>

                                </form>
                            </div> -->


                        </template>
                    </collapse-panel>

                </div>



            </div>

            <!-- Left panel -->
            <div id="tree_panel" style="width: 70%; background-color: lightblue; border: 1px solid black;">
                <!-- <svg style="width: 100%; height: 100%; background-color: #FAFAFA;"></svg> -->
                <svg ref="svg" preserveAspectRatio="xMidYMid meet"
                    style="width: 100%; height: 100%; background-color: #FAFAFA;"></svg>

            </div>

            <!-- Right panel -->
            <div id="right_panel"
                style="width: 15%; background-color: #FAFAFA; padding: 3px;  overflow: auto;border: 1px solid black;border-left: none;">

                <!-- <div style="display: flex; justify-content: space-between;">
                    <span> <button @click="showTab('info')">Node information</button></span>
                    <span><button @click="showTab('help')">Help</button></span>

                </div> -->


                <div style="display: flex; justify-content: space-between; margin-top:4px;margin-bottom: 4px;">
                    <div style="
                                width: 100%;
                                background-color: #FFA726;
                                color: white;
                                padding: 6px 0;
                                font-size: 14px;
                                font-weight: bold;
                                border-radius: 4px;
                                text-align: center;
                                user-select: none;
                                box-shadow: 1px 1px 3px rgba(0,0,0,0.1);
                                ">
                        Node Information
                    </div>

                </div>



                <div id="info" v-show="isShowInfoTab">

                    <div>
                        <div style="margin-top: 10px;">

                            <collapse-panel>
                                <template #title>
                                    <strong>Basic:</strong>

                                </template>
                                <template #content>
                                    <div style="padding: 4px; font-size: 12px;">
                                        <div> <strong>Node id:</strong> {{ selectedNode && selectedNode.id || null }}
                                        </div>
                                        <div><strong>Node name:</strong> {{ selectedNode && selectedNode.name || null }}
                                        </div>
                                        <div><strong>Node type:</strong> {{ isLeafNode2Label(selectedNode) }}</div>
                                        <div><strong>Branch Length:</strong> {{ selectedNode &&
                                            selectedNode.branch_length || null }}</div>
                                        <div><strong>Sample szie:</strong> {{getSampleSize(selectedNode)}} <helper
                                                :color="'#000'">
                                                Sample Size only count the samples(leaf nodes). Non-leaf nodes will be
                                                ignored.</helper>
                                        </div>
                                        <div>
                                            <strong>Confidence:</strong>
                                            {{selectedNode && selectedNode.confidence || null }}

                                        </div>
                                    </div>
                                </template>
                            </collapse-panel>
                        </div>

                        <div style="margin-top: 10px;">

                            <collapse-panel>
                                <template #title>
                                    <strong>Composition:</strong>

                                </template>
                                <template #content>
                                    <div
                                        style="max-height: 300px; overflow: auto; border: 1px solid #ccc; font-size: 12px;">
                                        <div style="padding: 4px; background-color: #ccc;">
                                            <div style="display: flex; justify-content: space-between;">
                                                <span>Name</span>
                                                <span>Count [Porpotion]</span>
                                            </div>
                                        </div>

                                        <div v-for="item in getPieChartData((selectedNode && selectedNode.pieValues) || [], main_color_map)"
                                            :key="item.label" :style="{ backgroundColor: item.color, padding: '4px' }">
                                            <div style="display: flex; justify-content: space-between;">
                                                <span>{{ item.label }}</span>
                                                <span>{{ item.count }} [{{ (item.value *100) .toFixed(2) }}%]</span>
                                            </div>
                                        </div>

                                    </div>

                                </template>

                            </collapse-panel>
                        </div>

                        <div style="margin-top: 10px;">

                            <collapse-panel>
                                <template #title>
                                    <strong>Sample details:</strong>
                                </template>
                                <template #content>
                                    <div style="max-height: 500px; overflow: auto; border: 1px solid #ccc;">
                                        <div style="margin-top: 6px; display: flex; justify-content: right;">
                                            <button @click="exportSampleDetailsAsCSV">Download</button>
                                        </div>


                                        <div
                                            style="margin-top: 6px; display: flex; justify-content: center; align-items: center; gap: 6px;">
                                            <button @click="changePage(-1)" :disabled="currentPage === 1">
                                                Prev</button>
                                            <span>Page {{ currentPage }} / {{ totalPages }}</span>
                                            <button @click="changePage(1)" :disabled="currentPage === totalPages">Next
                                            </button>
                                        </div>
                                        <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
                                            <thead>
                                                <tr>
                                                    <th v-for="header in selectedNodeChildrenMata.table_header"
                                                        :key="header"
                                                        style="position: sticky; top: 0; background: #f0f0f0; padding: 4px;">
                                                        {{ header }}
                                                    </th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr v-for="row in pagedTableData" :key="row['Sample Name']">
                                                    <td v-for="header in selectedNodeChildrenMata.table_header"
                                                        :key="header" style="padding: 4px;">
                                                        {{ row[header] }}
                                                    </td>
                                                </tr>
                                            </tbody>
                                        </table>

                                        <div
                                            style="margin-top: 6px; display: flex; justify-content: center; align-items: center; gap: 6px;">
                                            <button @click="changePage(-1)" :disabled="currentPage === 1">
                                                Prev</button>
                                            <span>Page {{ currentPage }} / {{ totalPages }}</span>
                                            <button @click="changePage(1)" :disabled="currentPage === totalPages">Next
                                            </button>
                                        </div>


                                    </div>
                                </template>
                            </collapse-panel>



                        </div>
                    </div>
                </div>
                <!-- <div id="help" v-show="tabs.help">
                    <div class="section-title">Layout</div>
                    <ul>
                        <li><strong>Header</strong>: Contains the tool title, a metadata selector dropdown, a palette
                            toggle button, and basic node/sample counts.</li>
                        <li><strong>Left Panel (Tree)</strong>: Shows the interactive phylogenetic tree with zoom/pan
                            support.</li>
                        <li><strong>Right Panel (Info)</strong>: Displays detailed information about the selected node.
                        </li>
                        <li><strong>Footer</strong>: Includes external links to lab websites.</li>
                    </ul>
                    <div class="section-title">Interactions</div>
                    <ul>
                        <li><strong>Metadata Selection</strong>: Use the dropdown to choose a metadata field for
                            coloring and analysis.</li>
                        <li><strong>Color Palette</strong>: Click the <code>Palette</code> button to toggle the display
                            of color legends based on the selected metadata.</li>
                        <li><strong>Zoom & Pan</strong>: Use mouse wheel to zoom and drag to pan around the tree.</li>
                        <li><strong>Node Shapes</strong>:
                            <ul>
                                <li>Leaf nodes are drawn as colored triangles based on metadata values.</li>
                                <li>Internal nodes are drawn as pie charts representing the distribution of child
                                    metadata.</li>
                            </ul>
                        </li>
                        <li><strong>Click Node</strong>: Clicking a node will update the right panel to show:
                            <ul>
                                <li>Node ID, name, type, branch length, sample count.</li>
                                <li>A pie chart summary of metadata composition.</li>
                                <li>A table listing metadata of all descendant leaf nodes.</li>
                            </ul>
                        </li>
                        <li><strong>Tabs</strong>: Switch between <code>Information</code> and <code>Help</code> using
                            the buttons above the right panel.</li>
                    </ul>
                </div> -->
            </div>
        </div>

        <!-- Footer -->
        <div id="footer" class="footer"
            style=" padding-left: 10px; display: flex;  justify-content: space-between; align-items: center; height: 5vh; ">
            <div>
                <a href="https://fritzsedlazeck.github.io/"
                    style="text-decoration: none; color:blueviolet; padding-right: 5px;" target="_blank">@Sedlazeck
                    Lab</a>



            </div>
            <div>
                

                <help-popup></help-popup>
            </div>
        </div>
    </div>

    <script>

        let tree_data = [/*inject_data*/]
        let tree_meta = [/*inject_meta*/]

    </script>


    <script>
        const { createApp, reactive } = Vue;

        const app = createApp({
            data() {
                return {
                    title: "Read2TreeView",
                    selectedNodeName: null,
                    selectedNodeMeta: null,
                    selectedNode: null,
                    selectedNodeChildrenMata: {
                        table_header: [],
                        table_data: [],
                    },
                    tabs: {
                        "info": true,
                        "help": false,
                    },
                    node_list: [],
                    main_color_map: null,
                    num_leaf_nodes: 0,
                    meta_names: [],
                    selectedMeta: null,
                    root_tree: null,
                    showPalette: false,
                    svg: null,
                    isShowInfoTab: false,
                    highlightedNodeId: null,
                    meta_keys: {},
                    svgwidth: 1500,
                    svgheight: 900,
                    currentPage: 1,
                    pageSize: 10,
                    color_cache_map: {},
                    applied_meta_filters: [],
                    is_confidence_applied: false,
                    confidence_filter: {
                        min: 0,
                        max: 100,
                    },
                    metadata_filters: {

                    },

                    extraMeta1: null,
                    extraMeta2: null,
                    extraMeta3: null,
                    extraMeta1ColorMap: null,
                    extraMeta2ColorMap: null,
                    extraMeta3ColorMap: null,
                    extraMeta1Names: [],
                    extraMeta2Names: [],
                    extraMeta3Names: [],


                };
            },

            watch: {
                selectedMeta(newValue) {
                    if (newValue && this.root_tree) {
                        const pieCategories = new Set();
                        this.collectPieValues(this.root_tree, newValue, pieCategories);
                        this.main_color_map = this.color_cache_map[newValue].colorMap;

                        this.meta_names.forEach((meta) => {
                            if (meta !== newValue) {
                                this.extraMeta1Names.push(meta);
                                this.extraMeta2Names.push(meta);
                                this.extraMeta3Names.push(meta);
                            }
                        });

                        this.drawTree();
                    }
                },

                extraMeta1(newValue) {
                    if (newValue && this.root_tree) {

                        this.extraMeta1ColorMap = this.color_cache_map[newValue].colorMap;

                        this.drawTree();
                    }
                },
                extraMeta2(newValue) {
                    if (newValue && this.root_tree) {

                        this.extraMeta2ColorMap = this.color_cache_map[newValue].colorMap;
                        // console.log(this.extraMeta2ColorMap);
                        this.drawTree();
                    }
                },
                extraMeta3(newValue) {
                    if (newValue && this.root_tree) {

                        this.extraMeta3ColorMap = this.color_cache_map[newValue].colorMap;
                        this.drawTree();
                    }
                },

            },
            computed: {
                pagedTableData() {
                    const data = this.selectedNodeChildrenMata.table_data || [];
                    const start = (this.currentPage - 1) * this.pageSize;
                    return data.slice(start, start + this.pageSize);
                },
                totalPages() {
                    const data = this.selectedNodeChildrenMata.table_data || [];
                    return Math.max(1, Math.ceil(data.length / this.pageSize));
                }

            },

            methods: {

                exportSVG() {
                    const svgNode = this.svg.node();
                    const serializer = new XMLSerializer();
                    const source = serializer.serializeToString(svgNode);

                    // Add xmlns attribute
                    const svgBlob = new Blob(
                        ['<?xml version="1.0" standalone="no"?>\n' + source],
                        { type: 'image/svg+xml;charset=utf-8' }
                    );

                    const url = URL.createObjectURL(svgBlob);
                    const link = document.createElement("a");
                    link.href = url;
                    link.download = "read2treeview.svg";
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                },



                apply_filter() {

                    console.log(this.metadata_filters);

                    this.filterTree(this.metadata_filters, this.confidence_filter);

                    this.drawTree();
                },

                filterTree(metadata_filters, confidence_filter) {

                    this.root_tree.descendants().forEach(node => {


                        node.passed = true;
                        if (!node.isLeaf) {


                            if (this.is_confidence_applied) {
                                if (node.data.confidence === "NA") {
                                    console.log(":aa")
                                    node.passed = false;
                                } else {
                                    if (node.data.confidence < confidence_filter.min || node.data.confidence > confidence_filter.max) {
                                        node.passed = false;

                                    }
                                }

                            }

                        } else {
                            // apply metadata filters

                            for (const [key, filter] of Object.entries(metadata_filters)) {
                                if (filter.applied) {
                                    if (filter.std_type === "cont") {
                                        if (node.data.meta[key] < filter.min || node.data.meta[key] > filter.max) {
                                            node.passed = false;
                                        }
                                    } else if (filter.std_type === "cate") {
                                        if (!filter.selected.includes(node.data.meta[key])) {
                                            node.passed = false;
                                        }
                                    }
                                }
                            }


                        }

                        // if (node.passed ){
                        // console.log(node.data.confidence);
                        // console.log(node.passed);
                        // console.log(node.data.meta);

                        // console.log(node.isLeaf);
                        // console.log("-------------")
                        // }


                    });
                },


                changeCanvasReDrawTree(direction, operation) {
                    if (direction === "width") {
                        this.svgwidth += operation;

                    } else if (direction === "height") {
                        this.svgheight += operation;
                    }
                    this.svg.attr("viewBox", `0 0 ${this.svgwidth} ${this.svgheight}`);
                    this.drawTree();
                },

                changePage(offset) {
                    const newPage = this.currentPage + offset;
                    if (newPage >= 1 && newPage <= this.totalPages) {
                        this.currentPage = newPage;
                    }
                },


                isLeafNode2Label(d) {

                    if (!d) return "";
                    if (!d.children || d.children.length === 0) {
                        return "Leaf Node";
                    } else {
                        return "Non-leaf Node";
                    }
                },

                isLeafNode(d) {
                    if (!d) return null;
                    if (!d.children || d.children.length === 0) {
                        return true;
                    } else {
                        return false;
                    }
                },

                getSampleSize(d) {
                    // console.log(d && d.pieValues);
                    // console.log(d && Object.keys(d.pieValues).length)
                    // return ""
                    if (!d) return "";
                    // if (!d.pieValues) return "";
                    if (!d.children || d.children.length === 0) {
                        return 1;
                    } else {
                        return d && Object.keys(d.pieValues).length;
                    }
                },

                getLeafMetaAsTable(d) {

                    if (!d || !d.data.cached_leaf_table) {
                        return {
                            table_header: [],
                            table_data: []
                        };
                    }
                    return d.data.cached_leaf_table;

                },


                cachePieValuesAndColorMap(meta_name) {
                    const pieCategories = new Set();
                    const root = this.root_tree;

                    // 自底向上递归构建 pieValues（原始版本丢失非叶节点数据）
                    function collect(node) {
                        if (!node.children || node.children.length === 0) {
                            const value = node.data.meta?.[meta_name];
                            node.data.pieValues = [value];
                            pieCategories.add(value);
                            return [value];
                        } else {
                            const values = node.children.flatMap(child => collect(child));
                            node.data.pieValues = values;
                            return values;
                        }
                    }

                    collect(root);  // 从根节点递归开始

                    const colorMap = this.getColors(Array.from(pieCategories));
                    // this.color_cache[meta_name] = colorMap;
                    this.main_color_map = colorMap;
                },


                onNodeClick(d) {

                    if (this.highlightedNodeId !== null) {
                        d3.select(`#node-${this.highlightedNodeId} .outline`)
                            .attr("stroke", "black")
                            .attr("stroke-width", 0);
                    }

                    d3.select(`#node-${d.data.id} .outline`)
                        .attr("stroke", "red")
                        .attr("stroke-width", 2);

                    this.highlightedNodeId = d.data.id;

                    this.selectedNodeName = d.data.name || "(unnamed)";
                    this.selectedNodeMeta = d.data.meta || null;
                    this.selectedNode = d.data;

                    this.selectedNodeChildrenMata = null;
                    let childrenmeta = this.getLeafMetaAsTable(d);
                    this.selectedNodeChildrenMata = childrenmeta;
                    this.isShowInfoTab = true;
                },

                onLinkClick(L) {

                },

                getPieChartData(items, colorMap) {
                    const countMap = {};
                    // console.log(items);
                    if (!items) return [];
                    if (!items.length) return [];
                    if (colorMap === undefined) return [];
                    if (colorMap === null) return [];


                    for (const item of items) countMap[item] = (countMap[item] || 0) + 1;
                    const total = items.length;

                    let out = Object.entries(countMap).map(([label, count]) => ({
                        label,
                        value: count / total,
                        count,
                        color: colorMap[label] || '#cccccc'
                    }));

                    out = out.sort((a, b) => b.count - a.count);

                    return out
                },

                collectPieValues(node, metaname, categorySet) {
                    if (!node.children || node.children.length === 0) {
                        const value = node.data.meta[metaname];
                        node.data.pieValues = [value];
                        categorySet.add(value);
                        return [value];
                    }
                    const values = node.children.flatMap(child => this.collectPieValues(child, metaname, categorySet));
                    node.data.pieValues = values;
                    return values;
                },

                getColors(categories) {
                    const colorScale = d3.scaleOrdinal(d3.schemeCategory10);
                    const colorMap = {};
                    categories.forEach(cat => colorMap[cat] = colorScale(cat));
                    return colorMap;
                },

                showTab(tab) {
                    for (const key in this.tabs) {
                        this.tabs[key] = false;
                    }
                    this.tabs[tab] = true;
                },

                assign_nchildren(node) {
                    if (!node.children || node.children.length === 0) {
                        node.data.nchild = 0;
                        return 0;
                    }
                    const count = node.children.reduce((sum, child) => sum + 1 + this.assign_nchildren(child), 0);
                    node.data.nchild = count;
                    return count;
                },

                createRadiusScaler(root) {
                    const counts = root.descendants().map(d => d.data.nchild);
                    const min = Math.sqrt(Math.min(...counts) + 1);
                    const max = Math.sqrt(Math.max(...counts) + 1);
                    return (n) => {
                        const scaled = Math.sqrt(n + 1);
                        return ((scaled - min) / (max - min)) * (10 - 3) + 3;
                    };
                },

                exportSampleDetailsAsCSV() {
                    if (!this.selectedNodeChildrenMata || !this.selectedNodeChildrenMata.table_data) return;

                    const header = this.selectedNodeChildrenMata.table_header;
                    const rows = this.selectedNodeChildrenMata.table_data;

                    const csvContent = [
                        header.join(","),
                        ...rows.map(row => header.map(h => JSON.stringify(row[h] || "")).join(","))
                    ].join("\n");

                    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
                    const url = URL.createObjectURL(blob);

                    const link = document.createElement("a");
                    link.setAttribute("href", url);
                    link.setAttribute("download", `sample_details_node_${this.selectedNode?.id || "unknown"}.csv`);
                    link.style.visibility = "hidden";
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                },


                drawTree() {

                    const vueThis = this;

                    this.svg.selectAll("*").remove();

                    let tree_panel = document.getElementById("tree_panel");


                    const width = this.svgwidth
                    const height = this.svgheight

                    this.svg.attr("viewBox", `0 0 ${width + 160} ${height + 160}`);

                    const g = this.svg.append("g").attr("transform", "translate(80,80)");

                    const zoom = d3.zoom()
                        .scaleExtent([0.3, 15])
                        .on("zoom", (event) => {
                            g.attr("transform", event.transform);
                        });

                    this.svg.call(zoom).call(zoom.transform, d3.zoomIdentity.translate(80, 80));




                    function assignLeafColors(node, metaname, colorMap) {

                        if (!node.children || node.children.length === 0) {

                            node.data.color = colorMap[node.data.meta[metaname]];
                        } else {
                            node.children.forEach(child => assignLeafColors(child, metaname, colorMap));
                        }
                    }

                    function renderLinks(group, root) {
                        group.selectAll(".link")
                            .data(root.links())
                            .enter()
                            .append("path")
                            .attr("class", "link")
                            .attr("d", d => `M${d.source.x},${d.source.y}V${d.target.y}H${d.target.x}`);
                    }

                    function renderNodes(group, root, colors) {
                        vueThis.num_leaf_nodes = 0;

                        const nodes = group.selectAll(".node")
                            .data(root.descendants())
                            .enter().append("g")
                            .attr("class", "node")
                            .attr("id", d => `node-${d.data.id}`)
                            .attr("transform", d => `translate(${d.x},${d.y})`);

                        // let meta_names = new Set();

                        nodes.each(function (d) {
                            const r = d.data.radius || 3;
                            const nodeGroup = d3.select(this);

                            // capture the click event on the node group
                            nodeGroup.on("click", () => {
                                vueThis.onNodeClick(d);
                            });


                            if (!d.children || d.children.length === 0) {



                                const side = r * 2;
                                const strokeWidth = 0.25;

                                const unit = side / 10;

                                // outer rect
                                nodeGroup.append("rect")
                                    .attr("class", "outline")
                                    .attr("x", -side / 2)
                                    .attr("y", -side / 2)
                                    .attr("width", side)
                                    .attr("height", side)
                                    .attr("fill", "none")
                                    .attr("stroke", "black")
                                    .attr("stroke-width", 0);

                                // left top (7x7)
                                nodeGroup.append("rect")
                                    .attr("x", -side / 2)
                                    .attr("y", -side / 2)
                                    .attr("width", unit * 7)
                                    .attr("height", unit * 7)
                                    .attr("fill", d.passed ? d.data.color : "#D3D3D3")
                                    .attr("stroke", "#ccc")
                                    .attr("stroke-width", strokeWidth);

                                // right top (3x7)



                                nodeGroup.append("rect")
                                    .attr("x", -side / 2 + unit * 7)
                                    .attr("y", -side / 2)
                                    .attr("width", unit * 3)
                                    .attr("height", unit * 7)
                                    .attr("fill", () => {
                                        if (!d.passed) {
                                            return "#D3D3D3";
                                        }
                                        else {

                                            if (vueThis.extraMeta1 === null) {
                                                return "#FFF";
                                            } else {
                                                let this_meta = d.data.meta[vueThis.extraMeta1];

                                                return vueThis.extraMeta1ColorMap[this_meta];
                                            }

                                        }
                                    })
                                    .attr("stroke", "#ccc")
                                    .attr("stroke-width", strokeWidth);

                                // left bottom (7x3)
                                nodeGroup.append("rect")
                                    .attr("x", -side / 2)
                                    .attr("y", -side / 2 + unit * 7)
                                    .attr("width", unit * 7)
                                    .attr("height", unit * 3)
                                    .attr("fill", () => {
                                        if (!d.passed) {
                                            return "#D3D3D3";
                                        }
                                        else {

                                            if (vueThis.extraMeta2 === null) {
                                                return "#FFF";
                                            } else {
                                                let this_meta = d.data.meta[vueThis.extraMeta2];

                                                return vueThis.extraMeta2ColorMap[this_meta];
                                            }

                                        }
                                    })
                                    .attr("stroke", "#ccc")
                                    .attr("stroke-width", strokeWidth);

                                // right bottom (3x3)
                                nodeGroup.append("rect")
                                    .attr("x", -side / 2 + unit * 7)
                                    .attr("y", -side / 2 + unit * 7)
                                    .attr("width", unit * 3)
                                    .attr("height", unit * 3)
                                    .attr("fill", () => {
                                        if (!d.passed) {
                                            return "#D3D3D3";
                                        }
                                        else {

                                            if (vueThis.extraMeta3 === null) {
                                                return "#FFF";
                                            } else {
                                                let this_meta = d.data.meta[vueThis.extraMeta3];

                                                return vueThis.extraMeta3ColorMap[this_meta];
                                            }

                                        }
                                    })
                                    .attr("stroke", "#ccc")
                                    .attr("stroke-width", strokeWidth);

                                vueThis.num_leaf_nodes += 1;
                            } else {
                                const pieData = vueThis.getPieChartData(d.data.pieValues, colors);
                                // console.log(d);
                                nodeGroup.append("circle")
                                    .attr("class", "outline")
                                    .attr("r", r)
                                    .attr("fill", "none")
                                    .attr("stroke", "black")
                                    .attr("stroke-width", 0);

                                const pie = d3.pie().value(d => d.value)(pieData);
                                const arc = d3.arc().innerRadius(0).outerRadius(r);
                                nodeGroup.selectAll("path")
                                    .data(pie)
                                    .enter()
                                    .append("path")
                                    .attr("d", arc)
                                    .attr("fill", sec => {
                                        // console.log(d);
                                        if (d.passed) {
                                            return sec.data.color;
                                        } else {
                                            return "#D3D3D3";
                                        }
                                    });
                            }
                        });
                    }


                    let root = vueThis.root_tree;





                    const treeLayout = d3.tree()
                        .size([width, height])
                        .separation((a, b) => {
                            const r1 = a.data.radius * 2 || 3;
                            const r2 = b.data.radius * 2 || 3;
                            return (r1 + r2 + 10) / 8;
                        });
                    treeLayout(root);

                    // const pieCategories = new Set();


                    // console.log(this.color_cache);
                    // console.log(this.pie_value_cache);
                    assignLeafColors(root, vueThis.selectedMeta, this.color_cache_map[vueThis.selectedMeta].colorMap);

                    renderLinks(g, root);
                    renderNodes(g, root, this.main_color_map);

                    this.node_list = root.descendants().map(d => {
                        // console.log(d);
                        return {
                            id: d.id,
                            data: d.data,
                            depth: d.depth,
                            height: d.height,
                            x: d.x,
                            y: d.y,
                        }
                    });
                    // this.colormap = colorMap;

                    // console.log(this.node_list[0]);

                    // });
                },

                async prepareTree() {
                    const data = tree_data; // Replace with your actual data


                    // const data = await d3.json("aa.tree.json");
                    // const tree_meta = await d3.json("aa.tree_meta.json");
                    const tree = d3.hierarchy(data);
                    console.log(tree);
                    this.root_tree = tree;
                    this.meta_keys = tree_meta;

                    Object.values(tree_meta["meta_keys"]).forEach((item) => {
                        let data = {
                            name: item.name,
                            std_type: item.std_type,
                            min: item.min,
                            max: item.max,
                            selected: [],
                            applied: false
                        }

                        this.metadata_filters[item.name] = data;
                    });

                    this.meta_names = Object.keys(tree_meta["meta_keys"]);

                    const estimatedWidth = this.meta_keys["estimated_width"] || 100;
                    this.svgwidth = Math.min(Math.max(estimatedWidth * 80, 1000), 5000);
                    this.svgheight = Math.min(Math.max(estimatedWidth * 2, 1300), 4000);
                    // console.log(this.meta_names);
                    let color_cache_map = {}
                    this.meta_names.map(k => {
                        color_cache_map[k] = {
                            name: k,
                            categories: new Set(),
                        }
                    });


                    this.root_tree.descendants().forEach(d => {

                        this.meta_names.forEach(k => {
                            if (d.data.meta && d.data.meta[k]) {
                                color_cache_map[k].categories.add(d.data.meta[k]);
                            }
                        });

                        const isLeaf = !d.children || d.children.length === 0;

                        if (isLeaf) {
                            d.isLeaf = true;
                        } else {
                            d.isLeaf = false;
                        }

                        d.passed = true;

                        const leaves = isLeaf
                            ? [d]
                            : d.descendants().filter(n => !n.children || n.children.length === 0);

                        const firstWithMeta = leaves.find(n => n.data.meta);
                        const metaKeys = firstWithMeta ? Object.keys(firstWithMeta.data.meta || {}) : [];

                        d.data.cached_leaf_table = {
                            table_header: ["Sample Name", ...metaKeys],
                            table_data: leaves.map(n => {
                                const row = { "Sample Name": n.data.name || "(unnamed)" };
                                for (const k of metaKeys) {
                                    row[k] = n.data.meta ? n.data.meta[k] : null;
                                }
                                return row;
                            })
                        };
                    });

                    this.assign_nchildren(this.root_tree);
                    const radiusScaler = this.createRadiusScaler(this.root_tree);
                    this.root_tree.descendants().forEach(d => d.data.radius = radiusScaler(d.data.nchild));
                    Object.keys(color_cache_map).forEach((key) => {
                        let item = color_cache_map[key];
                        const colorMap = this.getColors(Array.from(item.categories));
                        color_cache_map[key].colorMap = colorMap;
                    });

                    this.color_cache_map = color_cache_map;

                    console.log(this.color_cache_map);
                }


            },
            mounted() {
                this.svg = d3.select("svg");  // 保存引用
                this.prepareTree().then(() => {
                    this.selectedMeta = this.meta_names[0] || null;
                    this.drawTree();

                });
            }
        });


        app.component('collapse-panel', {
            template: `
                    <div style="background-color: #f7f5f5; border: 1px solid #ccc; border-radius: 4px; margin-bottom: 10px;">
                    <div style="font-size: 12px; display: flex; align-items: center; justify-content: space-between; background: #eee; padding: 6px 10px; cursor: pointer;" @click="toggle">
                        <slot name="title"></slot>
                        <button style="font-size: 12px;">{{ isOpen ? 'Hide' : 'Show' }}</button>
                    </div>
                    <div v-show="isOpen" style="margin-top: 4px;">
                        <slot name="content"></slot>
                    </div>
                    </div>
                `,
            data() {
                return {
                    isOpen: true
                }
            },
            methods: {
                toggle() {
                    this.isOpen = !this.isOpen;
                }
            }
        });
        app.component('helper', {
            props: {
                color: {
                    type: String,
                    default: '#FFF'
                }
            },
            data() {
                return {
                    showTooltip: false,
                    tooltipStyle: {
                        left: '50%',
                        transform: 'translateX(-50%)',
                        top: '120%',
                        right: 'auto'
                    }
                };
            },
            mounted() {
                window.addEventListener("resize", this.adjustTooltipPosition);
            },
            beforeUnmount() {
                window.removeEventListener("resize", this.adjustTooltipPosition);
            },
            methods: {
                adjustTooltipPosition() {
                    this.$nextTick(() => {
                        const tooltip = this.$el.querySelector('.tooltip-content');
                        if (!tooltip) return;

                        const rect = tooltip.getBoundingClientRect();
                        const overflowRight = rect.right > window.innerWidth;
                        const overflowLeft = rect.left < 0;

                        if (overflowRight) {
                            this.tooltipStyle.left = 'auto';
                            this.tooltipStyle.right = '0';
                            this.tooltipStyle.transform = 'translateX(0%)';
                        } else if (overflowLeft) {
                            this.tooltipStyle.left = '0';
                            this.tooltipStyle.right = 'auto';
                            this.tooltipStyle.transform = 'translateX(0%)';
                        } else {
                            this.tooltipStyle.left = '50%';
                            this.tooltipStyle.right = 'auto';
                            this.tooltipStyle.transform = 'translateX(-50%)';
                        }
                    });
                }
            },
            template: `
            <div class="help-tooltip-wrapper" 
                @mouseenter="showTooltip = true; adjustTooltipPosition()" 
                @mouseleave="showTooltip = false">
                <div class="help-icon" :style="{ color: color }"><strong> ⓘ</strong></div>
                <div 
                    class="tooltip-content"
                    v-show="showTooltip"
                    :style="tooltipStyle"
                >
                    <div style="padding: 4px; font-size: 12px; margin-top: 10px; max-width: 400px; word-wrap: break-word; white-space: normal;z-index: 100;">
                        <slot></slot>
                    </div>
                </div>
            </div>
            `
        });


        app.component('palette', {
            props: ['colorMap'],
            data() {
                return {
                    show: false
                };
            },
            template: `
            <div style="position: relative; display: inline-block;">
            <button @click="show = !show">Palette</button>

            <div v-show="show" style="
                position: absolute;
                top: 110%;
                left: 50%;
                transform: translateX(-50%);
                background-color: white;
                border: 1px solid black;
                padding: 10px;
                z-index: 10;
                color: black;
                min-width: 150px;
            ">
                <h4 style="margin: 0 0 8px 0;">Color Palette</h4>
                <div style="max-height:200px; overflow-y: auto;">
                <div v-for="(color, label) in colorMap" :key="label"
                    style="display: flex; align-items: center; margin-bottom: 4px;">
                    <div :style="{ backgroundColor: color, width: '20px', height: '20px', marginRight: '5px' }"></div>
                    {{ label }}
                </div>
                </div>
            </div>
            </div>
        `
        });

        app.component('range-filter', {
            props: {
                minValue: {
                    type: Number,
                    required: true
                },
                maxValue: {
                    type: Number,
                    required: true
                },
                name: {
                    type: String,
                    default: 'Range Filter'
                }
            },
            emits: ['update:apply', 'update:range'],
            data() {
                return {
                    apply: false,
                    range: {
                        min: this.minValue,
                        max: this.maxValue
                    },
                    error: ''
                };
            },
            watch: {
                apply(val) {
                    this.$emit('update:apply', val);
                },
                range: {
                    handler(val) {
                        this.validateRange(val);
                    },
                    deep: true
                }
            },
            methods: {
                validateRange(val) {
                    if (val.min < this.minValue || val.max > this.maxValue) {
                        this.error = `Values must be between ${this.minValue} and ${this.maxValue}.`;
                    } else if (val.max <= val.min) {
                        this.error = `Max must be greater than Min.`;
                    } else {
                        this.error = '';
                        this.$emit('update:range', val);
                    }
                }
            },
            template: `
                <div style="padding: 6px 10px; font-size: 13px; display: flex; flex-direction: column; gap: 10px;">

                <!-- Checkbox -->
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <span style="font-weight: bold;">{{ name }}</span>
                    <helper color="#000">
                        <template v-slot:default>
                          
                        </template>
                    </helper>
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                   
                    <input type="checkbox" id="applyFilter" v-model="apply">
                    <label for="applyFilter" style="margin: 0;">Apply Filter</label>
                </div>

                <!-- Range inputs -->
                <div style="display: flex; justify-content: space-between; align-items: center; gap: 10px;">
                    <label for="min" style="min-width: 40px;">Min:</label>
                    <input type="number" id="min" v-model.number="range.min" :min="minValue" :max="maxValue" step="1"
                    style="flex: 1; padding: 2px; border: 1px solid #ccc; border-radius: 4px;">

                    <label for="max" style="min-width: 40px;">Max:</label>
                    <input type="number" id="max" v-model.number="range.max" :min="minValue" :max="maxValue" step="1"
                    style="flex: 1; padding: 4px; border: 1px solid #ccc; border-radius: 4px;">
                </div>

                <!-- Error message -->
                <div v-if="error" style="color: red; font-size: 12px; margin-top: 4px;">
                    {{ error }}
                </div>
                </div>
            `
        });


        app.component('category-filter', {
            props: {
                candidates: {
                    type: Array,
                    required: true
                },
                name: {
                    type: String,
                    default: 'Category Filter'
                }
            },
            emits: ['update:apply', 'update:selected'],
            data() {
                return {
                    apply: false,
                    selected: [],
                    error: '',
                    page: 1,
                    perPage: 10
                };
            },
            computed: {
                totalPages() {
                    return Math.ceil(this.candidates.length / this.perPage);
                },
                paginatedCandidates() {
                    const start = (this.page - 1) * this.perPage;
                    return this.candidates.slice(start, start + this.perPage);
                }
            },
            watch: {
                selected(val) {
                    this.validate();
                    this.$emit('update:selected', val);
                },
                apply(val) {
                    this.validate();
                    this.$emit('update:apply', val);
                }
            },
            methods: {
                validate() {
                    if (this.apply && this.selected.length === 0) {
                        this.error = '⚠️ You must select at least one category to apply the filter.';
                    } else {
                        this.error = '';
                    }
                },
                nextPage() {
                    if (this.page < this.totalPages) this.page++;
                },
                prevPage() {
                    if (this.page > 1) this.page--;
                },
                clear_all() {
                    this.selected = [];
                    this.apply = false;
                    this.error = '';
                }
            },
            template: `
    <div style="padding: 6px 10px; font-size: 13px; display: flex; flex-direction: column; gap: 10px; margin-top:4px; border-top: 1px solid #ccc; border-radius: 4px; background-color: #f7f5f5;">

      <!-- Title and help -->
      <div style="display: flex; align-items: center; justify-content: space-between;">
        <span style="font-weight: bold;">{{ name }}</span>
        <helper color="#000">
          <template v-slot:default>
            
          </template>
        </helper>
      </div>

      <!-- Apply checkbox -->
      <div style="display: flex; align-items: center; gap: 8px;">
        <input type="checkbox" id="applyFilter" v-model="apply">
        <label for="applyFilter" style="margin: 0;">Apply Filter</label>
      </div>

      <div style="display: flex; justify-content: flex-end;">
        <button @click="clear_all" style="font-size: 12px; padding: 2px 6px;">Clear All</button>
      </div>
      <!-- Error -->
      <div v-if="error" style="color: red; font-size: 12px; margin-top: 4px;">
        {{ error }}
      </div>
      <!-- Category options with pagination -->
      <div style="max-height: 200px; overflow-y: auto; border: 1px solid #ccc; padding: 4px; border-radius: 4px;background-color: #fff;">
        <label v-for="option in paginatedCandidates" :key="option" style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;">
          <input type="checkbox" :value="option" v-model="selected">
          {{ option }}
        </label>
      </div>

      <!-- Pagination controls -->
      <div v-if="totalPages > 1" style="display: flex; justify-content: space-between; align-items: center; margin-top: 4px;">
        <button @click="prevPage" :disabled="page === 1"> Prev</button>
        <span>Page {{ page }} / {{ totalPages }}</span>
        <button @click="nextPage" :disabled="page === totalPages">Next </button>
      </div>


    </div>
  `
        });


        app.component("help-popup", {
            data() {
                return {
                    visible: false
                };
            },
            methods: {
                toggleHelp() {
                    this.visible = !this.visible;
                }
            },
            template: `
    <div style="position: relative;">
      <button @click="toggleHelp"
        style="background-color: #FFA726; color: white; border: none; padding: 6px 12px; font-size: 13px; border-radius: 4px; cursor: pointer;">
        Help
      </button>

      <div v-if="visible" style="
        position: absolute;
        bottom: 120%;
        right: 0;
        width: 90vw;
        max-height: 80vh;
        overflow-y: auto;
        background: white;
        color: black;
        border: 2px solid #FFA726;
        border-radius: 8px;
        padding: 16px;
        z-index: 1000;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      ">
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <h3 style="margin: 0;">Read2TreeView Help</h3>
          <button @click="toggleHelp" style="background-color: #FB8C00;">Close</button>
        </div>
        <hr />
<div>
  <h2>Read2TreeView Documentation</h2>

  <h3>Layout Overview</h3>
  <p>The Read2TreeView application is structured into four primary layout regions:</p>
  <ul>
    <li><strong>Header:</strong> Contains palette configuration controls and metadata selectors.</li>
    <li><strong>Left Panel:</strong> Displays tree information and metadata-based filters.</li>
    <li><strong>Center Panel (Tree Panel):</strong> Renders the D3-based interactive phylogenetic tree.</li>
    <li><strong>Right Panel:</strong> Displays detailed information for the selected node.</li>
  </ul>

  <h3>Header</h3>
  <p>
    The header bar provides access to metadata selection and color palette configuration.
    Users can assign a main metadata attribute and up to three extra attributes to customize the color quadrants of leaf nodes.
    Each dropdown is paired with a <code>&lt;palette&gt;</code> component showing the color map.
  </p>

  <h3>Left Panel</h3>
  <p>
    Divided into two major sections:  </p>
    <ul>
      <li>
        <strong>Tree Information:</strong> Uses <code>&lt;collapse-panel&gt;</code> to show basic stats (e.g., node count, metadata types).
      </li>
      <li>
        <strong>Tree Filters:</strong> Includes confidence filter and metadata filters:
        <ul>
          <li>
            <code>&lt;range-filter&gt;</code>: for continuous metadata attributes, allows range selection.
          </li>
          <li>
            <code>&lt;category-filter&gt;</code>: for categorical metadata attributes, supports paginated multi-select.
          </li>
        </ul>
      </li>
    </ul>


  <h3>Tree Panel (Center)</h3>
  <p>
    This area is reserved for rendering the interactive D3 phylogenetic tree.  </p>
    Nodes are drawn as follows:
    <ul>
      <li>
        <strong>Leaf Nodes:</strong> Rendered as a 10x10 square subdivided into four colored quadrants (top-left = main palette, others = extra palettes).
      </li>
      <li>
        <strong>Non-leaf Nodes:</strong> Rendered as pie charts summarizing the composition of child metadata.
      </li>
    </ul>
    Clicking a node triggers detail display in the right panel.


  <h3>Right Panel</h3>
  <p>
    Displays detailed information about the selected node, split into three collapsible panels:</p>
    <ul>
      <li><strong>Basic:</strong> Node ID, name, type, branch length, sample size, and confidence.</li>
      <li><strong>Composition:</strong> A pie chart-like summary using <code>getPieChartData()</code>.</li>
      <li><strong>Sample Details:</strong> A paginated table of all leaf metadata under the node, with CSV download support.</li>
    </ul>
  



  <h3>Interaction Summary</h3>
  <ul>
    <li><strong>Zoom/Pan:</strong> Supported via D3 zoom on the SVG container.</li>
    <li><strong>Node Click:</strong> Highlights node and populates right panel with detailed data.</li>
    <li><strong>Filter Apply:</strong> Applies selected metadata and confidence filters to the tree.</li>
    <li><strong>Palette Toggle:</strong> Opens color legends for better interpretability.</li>
  </ul>


</div>

      </div>
    </div>
  `
        });



        app.mount("#app");

    </script>

</body>

</html>