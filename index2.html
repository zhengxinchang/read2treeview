<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>D3 Tree with Pie Chart Nodes (Cartesian)</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
        }

        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 1.5px;
        }

        .node text {
            font-size: 10px;
            text-anchor: middle;
            dominant-baseline: middle;
        }
    </style>
</head>

<body>
    <svg width="1200" height="1000"></svg>
    <script>
        const width = 1500;
        const height = 1000;

        const svg = d3.select("svg")
            .attr("viewBox", [0, 0, width, height])
            .call(d3.zoom()
                .scaleExtent([0.3, 15])
                .on("zoom", (event) => {
                    g.attr("transform", event.transform);
                }));

        const g = svg.append("g").attr("transform", "translate(80,80)");
        const color = d3.scaleOrdinal(d3.schemeCategory10);

        function getColors(categories) {
            // const categories = ["A", "B", "C", "D"];
            const colorScale = d3.scaleOrdinal(d3.schemeCategory10);  // 或 d3.schemeSet2 / d3.schemeTableau10 等

            const colorMap = {};
            categories.forEach(cat => {
                colorMap[cat] = colorScale(cat);
            });
            return colorMap;
        }


        function getPieChartData(items, colorMap) {
            const countMap = {};

            // 统计每个类别出现的次数
            for (const item of items) {
                countMap[item] = (countMap[item] || 0) + 1;
            }

            const total = items.length;

            // 组装成适合 pie chart 的格式
            const result = Object.entries(countMap).map(([key, count]) => {
                return {
                    label: key,
                    value: count / total,  // 百分比
                    count: count,          // 原始数量（可选）
                    color: colorMap[key] || '#cccccc'  // fallback color
                };
            });

            return result;
        }



        d3.json("tree_output.json").then(data => {
            const root = d3.hierarchy(data);



            function countDescendants(node) {
                if (!node.children || node.children.length === 0) {
                    node.data.nchild = 0;  // 没有子孙节点
                    return 0;
                }

                let count = 0;
                for (const child of node.children) {
                    count += 1 + countDescendants(child);  // 每个 child 本身 + 它的后代
                }

                node.data.nchild = count;
                return count;
            }

            countDescendants(root);


            let maxChildrenCount = 0;
            let minChildrenCount = Infinity;
            root.descendants().forEach(d => {
                if (d.data.nchild > maxChildrenCount) {
                    maxChildrenCount = d.data.nchild;
                }
                if (d.data.nchild < minChildrenCount) {
                    minChildrenCount = d.data.nchild;
                }
            });

            function scaleRadius(nleaf) {
                const minRadius = 3;
                const maxRadius = 10;

                // 平滑化处理，避免 sqrt(0)
                const scaled = Math.sqrt(nleaf + 1);

                // 找到 sqrt 范围的最大最小值用于归一化
                const minScaled = Math.sqrt(minChildrenCount + 1);
                const maxScaled = Math.sqrt(maxChildrenCount + 1);

                return ((scaled - minScaled) / (maxScaled - minScaled)) * (maxRadius - minRadius) + minRadius;
            }
            root.descendants().forEach(d => {
                d.data.radius = scaleRadius(d.data.nchild);
            });



            const treeLayout = d3.tree()
                .size([width, height])
                //   .size([height, width])
                .separation((a, b) => {
                    const r1 = a.data.radius * 2 || 3;
                    const r2 = b.data.radius * 2 || 3;
                    // 以节点半径总和加一个常数为距离
                    return (r1 + r2 + 10) / 6;
                });


            treeLayout(root);


            g.selectAll(".link")
                .data(root.links())
                .enter().append("path")
                .attr("class", "link")
                .attr("d", d => {
                    return `
      M${d.source.x},${d.source.y}
      V${d.target.y}
      H${d.target.x}
    `;
                });


            let pieChartCategories = new Set();


            function makePiechartDescendants(node, metaname) {
                if (!node.children || node.children.length === 0) {
                    // console.log(node.data.meta[metaname]);
                    // console.log(metaname);

                    // console.log(meta);
                    node.data.pieValues = [node.data.meta[metaname]];
                    // node.data.color = colorMap[category];
                    pieChartCategories.add(node.data.meta[metaname]);
                    return [node.data.meta[metaname]];
                }

                // console.log(node.data.meta)
                let PV = [];
                for (const child of node.children) {

                    prv = makePiechartDescendants(child, metaname);  // 每个 child 本身 + 它的后代
                    PV = PV.concat(prv);
                }

                node.data.pieValues = PV;
                return PV;
            }

            makePiechartDescendants(root, "host");

            console.log(pieChartCategories);
            let pieChartCategoriesArray = Array.from(pieChartCategories);
            let colors = getColors(pieChartCategoriesArray);

            console.log(root);
            console.log(colors);


            function assignColors(node, metaname) {
                if (!node.children || node.children.length === 0) {
                    const category = node.data.meta[metaname];
                    node.data.color = colors[category];
                } else {
                    node.children.forEach(child => assignColors(child, metaname));
                }
            }
            assignColors(root, "host");


            const node = g.selectAll(".node")
                .data(root.descendants())
                .enter().append("g")
                .attr("class", "node")
                .attr("transform", d => `translate(${d.x},${d.y})`);




            node.each(function (d) {


                const nodeRadius = d.data.radius || 3;

                if (!d.children || d.children.length === 0) {

                    // 非叶节点：画三角形
                    const side = nodeRadius * 2; // 控制三角形大小
                    const height = Math.sqrt(3) / 2 * side;
                    const points = [
                        [0, -height / 2],                  // 顶点
                        [-side / 2, height / 2],           // 左下
                        [side / 2, height / 2]             // 右下
                    ];

                    const trianglePath = d3.line()(points.concat([points[0]]));
                    console.log(d.data.color);

                    d3.select(this)
                        .append("path")
                        .attr("d", trianglePath)
                        .attr("fill", (d, i) => d.data.color)
                        .attr("stroke", "black")
                        .attr("stroke-width", 0.0);

                } else {

                    const pieChartData = getPieChartData(d.data.pieValues, colors);  // 格式：[{label, value, count, color}, ...]

                    const pie = d3.pie()
                        .value(d => d.value)(pieChartData);  // 用 value 来计算饼图角度

                    const arc = d3.arc()
                        .innerRadius(0)
                        .outerRadius(nodeRadius);

                    d3.select(this)
                        .selectAll("path")
                        .data(pie)
                        .enter()
                        .append("path")
                        .attr("d", arc)
                        .attr("fill", (d, i) => d.data.color);  // 从 pieChartData 中读取 color
                }
            });


            // 可选标签
            // node.append("text")
            //   .attr("dy", d => d.data.radius + 12)
            //   .text(d => d.data.name);
        });
    </script>
</body>

</html>